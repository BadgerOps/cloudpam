<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>CloudPAM</title>
    <style>
      :root {
        --bg: #f6f7fb;
        --card: #ffffff;
        --muted: #6b7280;
        --text: #0f172a;
        --border: #e5e7eb;
        --primary: #2563eb;
        --primary-600: #1d4ed8;
        --success: #059669;
        --danger: #dc2626;
        --radius: 12px;
        --shadow: 0 6px 20px rgba(0,0,0,0.08);
      }
      /* Hide cloaked elements until Alpine initializes */
      [x-cloak] { display: none !important; }
      body { background: var(--bg); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; }
      header { display:flex; align-items:center; gap:1rem; padding: 1.25rem 2rem; background: var(--card); box-shadow: var(--shadow); position: sticky; top: 0; z-index: 10; }
      header h1 { margin: 0; font-size: 20px; }
      .muted { color: var(--muted); }
      main { padding: 2rem; max-width: 1000px; margin: 0 auto; }
      .card { background: var(--card); border: 1px solid var(--border); border-radius: var(--radius); box-shadow: var(--shadow); padding: 1rem 1.25rem; }
      input, select { padding: 0.5rem 0.6rem; font-size: 14px; border-radius: 8px; border: 1px solid var(--border); background: #fff; color: var(--text); outline: none; }
      input:focus, select:focus { border-color: var(--primary); box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.15); }
      .btn { border: 1px solid var(--primary); color: #fff; background: var(--primary); padding: 0.5rem 0.8rem; border-radius: 8px; cursor: pointer; transition: background 0.15s ease, transform 0.04s ease; font-size: 14px; }
      .btn:hover { background: var(--primary-600); }
      .btn:active { transform: translateY(1px); }
      .btn.ghost { background: transparent; color: var(--primary); border-color: var(--primary); }
      .btn[disabled] { opacity: 0.5; cursor: not-allowed; }
      table { border-collapse: collapse; width: 100%; margin-top: 1rem; background: var(--card); border: 1px solid var(--border); border-radius: 10px; overflow: visible; }
      th, td { border-bottom: 1px solid var(--border); padding: 10px 12px; }
      th { background: #fafafa; text-align: left; font-weight: 600; }
      .row { display: flex; gap: 0.6rem; flex-wrap: wrap; }
      .status-used { color: var(--danger); font-weight: 600; }
      .status-free { color: var(--success); font-weight: 600; }
    </style>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
  </head>
  <body>
    <div x-data="toaster()" x-init="init()" style="position:fixed; right:16px; bottom:16px; display:flex; flex-direction:column; gap:10px; z-index:10000;">
      <template x-for="t in toasts" :key="t.id">
        <div :style="'background:#fff;border:1px solid '+(t.type==='error'?'#fecaca':'#bfdbfe')+';padding:10px 12px;border-radius:8px;box-shadow:var(--shadow);min-width:240px;'">
          <strong x-text="t.type==='error'?'Error':'Info'"></strong>
          <div x-text="t.message"></div>
        </div>
      </template>
    </div>
    <header>
      <h1>CloudPAM</h1>
      <span class="muted">Lightweight Cloud IPAM (AWS/GCP)</span>
    </header>

    <main x-data="tabState()" x-init="init()">
    <div class="card" style="margin-bottom:1rem; display:flex; gap:.5rem; align-items:flex-end;">
      <button :class="tab==='pools' ? 'btn' : 'btn ghost'" @click="tab='pools'">Pools</button>
      <button :class="tab==='accounts' ? 'btn' : 'btn ghost'" @click="tab='accounts'">Accounts</button>
      <button :class="tab==='analytics' ? 'btn' : 'btn ghost'" @click="tab='analytics'">Analytics</button>
    </div>
    <template x-if="tab==='pools'">
    <section x-data="pools()" x-init="init()" class="card">
      <h2>Top-level Pools</h2>
      <div class="row">
        <input type="text" placeholder="Name" x-model="form.name" />
        <input type="text" placeholder="CIDR (e.g., 10.0.0.0/16)" x-model="form.cidr" />
        <select x-model.number="form.account_id">
          <option :value="null">No Account</option>
          <template x-for="a in accounts" :key="a.id">
            <option :value="a.id" x-text="a.name + (a.provider ? ' ('+a.provider+')' : '')"></option>
          </template>
        </select>
        <button class="btn" @click="createTop()">Create</button>
        <span x-text="msg" class="muted"></span>
      </div>
      <div class="row" style="margin-top:1rem; align-items:center; gap:.75rem;">
        <input type="text" placeholder="Search..." x-model="search" style="flex:1; max-width:300px;" />
        <label>Page size
          <select x-model="pageSize" @change="page=1; load()">
            <option value="25">25</option>
            <option value="50">50</option>
            <option value="100">100</option>
            <option value="all">All</option>
          </select>
        </label>
        <div style="margin-left:auto; position:relative;">
          <button class="btn ghost" @click="bulkOpen=!bulkOpen" :disabled="!selectedTop.length" :title="selectedTop.length ? (selectedTop.length + ' selected') : 'Select rows to enable actions'">⋮</button>
          <div x-show="bulkOpen" x-cloak style="position:absolute; right:0; background:#fff; border:1px solid var(--border); border-radius:8px; box-shadow:var(--shadow); z-index:9999; min-width:180px;">
            <button class="btn ghost" style="display:block; width:100%; text-align:left;" @click="bulkOpen=false; openBulkAssignTop()">Assign Account…</button>
            <button class="btn ghost" style="display:block; width:100%; text-align:left; color:var(--danger);" @click="bulkOpen=false; openBulkDeleteTop()">Delete…</button>
          </div>
        </div>
      </div>
      <div style="overflow:auto;">
      <table style="min-width: 960px;">
        <thead>
          <tr><th style="width:32px;"><input type="checkbox" @change="toggleSelectAllTop($event)" :checked="allTopSelected()" :indeterminate="indeterminateTop()" /></th><th>ID</th><th>Name</th><th>CIDR</th><th>Account</th><th>Created</th><th></th></tr>
        </thead>
        <tbody>
          <template x-for="p in topLevel" :key="p.id">
            <tr>
              <td><input type="checkbox" :value="p.id" @change="toggleSelectTop(p.id)" :checked="selectedTop.includes(p.id)" /></td>
              <td x-text="p.id"></td>
              <td x-text="p.name"></td>
              <td x-text="p.cidr"></td>
              <td x-text="accountName(p.account_id)"></td>
              <td x-text="new Date(p.created_at).toLocaleString()"></td>
              <td style="text-align:right; position:relative;">
                <button class="btn ghost" @click="selectPool(p)">View</button>
              </td>
            </tr>
          </template>
          <tr x-show="topLevel.length === 0"><td colspan="5" style="color:#999">No pools yet</td></tr>
        </tbody>
      </table>

      <!-- Bulk Assign Top Pools -->
      <div x-show="bulkAssignTopOpen" x-cloak style="position:fixed; inset:0; background:rgba(0,0,0,.35); display:flex; align-items:center; justify-content:center; z-index:10010;">
        <div class="card" style="width:420px;">
          <h3>Assign Account to Selected</h3>
          <div class="row" style="align-items:center;">
            <select x-model.number="bulkAccountId" style="min-width: 14rem;">
              <option :value="null">No Account</option>
              <template x-for="a in accounts" :key="a.id">
                <option :value="a.id" x-text="a.name + (a.provider ? ' ('+a.provider+')' : '')"></option>
              </template>
            </select>
            <span class="muted" x-text="selectedTop.length + ' item(s)'" />
          </div>
          <div class="row" style="justify-content:flex-end; margin-top:1rem;">
            <button class="btn ghost" @click="bulkAssignTopOpen=false">Cancel</button>
            <button class="btn" @click="performBulkAssignTop()">Apply</button>
          </div>
        </div>
      </div>

      <!-- Bulk Delete Top Pools -->
      <div x-show="bulkDeleteTopOpen" x-cloak style="position:fixed; inset:0; background:rgba(0,0,0,.35); display:flex; align-items:center; justify-content:center; z-index:10010;">
        <div class="card" style="width:460px;">
          <h3>Delete Selected Pools</h3>
          <p class="muted">This action can delete multiple pools. You may enable cascade to delete their descendants.</p>
          <label style="display:flex; gap:.4rem; align-items:center;"><input type="checkbox" x-model="bulkCascade" /> Cascade delete descendants</label>
          <label style="display:flex; gap:.4rem; align-items:center; margin-top:.5rem;"><input type="checkbox" x-model="confirmBulkDelete" /> I understand this cannot be undone</label>
          <div class="row" style="justify-content:flex-end; margin-top:1rem;">
            <button class="btn ghost" @click="bulkDeleteTopOpen=false">Cancel</button>
            <button class="btn" :disabled="!confirmBulkDelete" @click="performBulkDeleteTop()">Delete</button>
          </div>
        </div>
      </div>

      <template x-if="current">
        <div style="margin-top: 2rem;" class="card">
          <h3>
            <span x-text="`Pool #${current.id}: ${current.name} (${current.cidr})`"></span>
            <span class="muted" x-show="current.account_id"> · Account:
              <strong x-text="accountName(current.account_id)"></strong>
            </span>
          </h3>
          <div class="row" style="margin: 0.25rem 0; align-items:center;">
            <label>Assign account:</label>
            <select x-model.number="currentAccountId" style="min-width: 14rem;">
              <option :value="null">No Account</option>
              <template x-for="a in accounts" :key="a.id">
                <option :value="a.id" x-text="a.name + (a.provider ? ' ('+a.provider+')' : '')"></option>
              </template>
            </select>
            <button class="btn ghost" @click="updateCurrentPoolAccount()">Update</button>
            <span class="muted" x-text="updateMsg"></span>
          </div>
          <div class="row" style="margin: 0.5rem 0; align-items:center;">
            <label>Block size (prefix):</label>
            <input type="number" :min="currentPrefixBits ? currentPrefixBits+1 : 16" max="32" x-model.number="blockPrefix" @change="if (currentPrefixBits!=null && blockPrefix <= currentPrefixBits) blockPrefix = Math.min(32, currentPrefixBits+1)" style="width:6rem" />
            <label>Per page:</label>
            <select x-model="pageSize" @change="onPageSize()">
              <option value="10">10</option>
              <option value="50">50</option>
              <option value="100">100</option>
              <option value="all">All</option>
            </select>
            <button class="btn" @click="loadBlocks()">List Blocks</button>
            <span x-text="subMsg" class="muted"></span>
          </div>
          <div class="row" style="margin: 0.5rem 0; align-items:center;">
            <button class="btn ghost" @click="firstPage()" :disabled="page<=1 || pageSize==='all'">First</button>
            <button class="btn ghost" @click="prevPage()" :disabled="page<=1 || pageSize==='all'">Prev</button>
            <span>Page</span>
            <input type="number" min="1" :max="totalPages" x-model.number="pageInput" style="width:5rem" />
            <button class="btn ghost" @click="goToPage()" :disabled="pageSize==='all'">Go</button>
            <span>of <strong x-text="totalPages"></strong></span>
            <button class="btn ghost" @click="nextPage()" :disabled="page>=totalPages || pageSize==='all'">Next</button>
            <button class="btn ghost" @click="lastPage()" :disabled="page>=totalPages || pageSize==='all'">Last</button>
            <span class="muted" x-show="total>0">Showing <strong x-text="fromItem"></strong>–<strong x-text="toItem"></strong> of <strong x-text="total"></strong></span>
            <div style="margin-left:auto; display:flex; gap:1rem; align-items:center;">
              <label style="display:flex; gap:.35rem; align-items:center;">
                <input type="checkbox" x-model="showOnlyUsed" @change="filterBlocks()" />
                Show only used
              </label>
              <label style="display:flex; gap:.35rem; align-items:center;">
                <input type="checkbox" x-model="hideUnavailable" @change="filterBlocks()" />
                Hide unavailable
              </label>
            </div>
          </div>

          <div class="card" style="margin: .5rem 0; padding:.75rem;">
            <div class="row" style="align-items:center; gap:.75rem;">
              <strong>IP Space Visualization</strong>
              <input type="text" placeholder="Search name or CIDR" x-model="vizSearch" @input="computeViz()" />
              <label>Accounts
                <select x-model="vizAccounts" multiple size="3" @change="computeViz()">
                  <template x-for="a in accounts" :key="a.id">
                    <option :value="String(a.id)" x-text="a.name"></option>
                  </template>
                </select>
              </label>
            </div>
            <div style="position:relative; height:16px; background:#eef2ff; border:1px solid var(--border); border-radius:6px; margin-top:.5rem; overflow:hidden;">
              <template x-for="seg in vizSegments" :key="seg.id">
                <div :title="seg.title" :style="`position:absolute; left:${seg.left}%; width:${seg.width}%; top:0; bottom:0; background:${seg.color}; opacity:.85;`"></div>
              </template>
            </div>
            <div class="muted" style="margin-top:.4rem;">
              <span x-text="vizSegments.length"></span> block(s) displayed
            </div>
          </div>

          <table>
            <thead>
              <tr>
                <th>Prefix</th>
                <th>Hosts</th>
                <th>Status</th>
                <th>Assigned Name</th>
                <th>Assigned Account</th>
                <th>Network IP</th>
                <th>Broadcast IP</th>
                <th>Action</th>
              </tr>
              <tr>
                <!-- No filter for Prefix (IP range) and Assigned Name -->
                <th></th>
                <th><input type="text" placeholder="Filter" x-model="blockFilters.hosts" @input="filterBlocks()" style="width:100%;" /></th>
                <th><input type="text" placeholder="used/free/unavailable" x-model="blockFilters.status" @input="filterBlocks()" style="width:100%;" /></th>
                <th></th>
                <th><input type="text" placeholder="Account" x-model="blockFilters.account" @input="filterBlocks()" style="width:100%;" /></th>
                <th><input type="text" placeholder="Network IP" x-model="blockFilters.network" @input="filterBlocks()" style="width:100%;" /></th>
                <th><input type="text" placeholder="Broadcast IP" x-model="blockFilters.broadcast" @input="filterBlocks()" style="width:100%;" /></th>
                <th></th>
              </tr>
            </thead>
            <tbody>
              <template x-for="b in blocks" :key="b.cidr">
                <tr>
                  <td x-text="b.cidr"></td>
                  <td x-text="b.hosts"></td>
                  <td>
                    <span :class="(b.used||blockUnavailable(b.cidr)) ? 'status-used' : 'status-free'"
                          :title="blockUnavailableReason(b.cidr)"
                          x-text="b.used ? 'Used' : (blockUnavailable(b.cidr) ? 'Unavailable' : 'Free')"></span>
                  </td>
                  <td>
                    <template x-if="b.assigned_id">
                      <a href="#" @click.prevent="selectPoolById(b.assigned_id)" x-text="b.assigned_name"></a>
                    </template>
                    <template x-if="!b.assigned_id">
                      <span>-</span>
                    </template>
                  </td>
                  <td x-text="b.assigned_account_name || accountName(b.assigned_account_id) || '-' "></td>
                  <td x-text="b.network_ip || '-' "></td>
                  <td x-text="b.broadcast_ip || '-' "></td>
                  <td>
                    <button class="btn" :disabled="b.used || blockUnavailable(b.cidr)" :title="blockUnavailableReason(b.cidr) || 'Create a sub-pool in this block'" @click="createSub(b)">Create Sub-pool</button>
                  </td>
              </tr>
              </template>
              <tr x-show="blocks.length === 0"><td colspan="8" style="color:#999">No blocks yet</td></tr>
            </tbody>
          </table>
        </div>
      </template>

      <!-- Edit Pool Modal -->
      <div x-show="editPoolOpen" x-cloak style="position:fixed; inset:0; background:rgba(0,0,0,.35); display:flex; align-items:center; justify-content:center; z-index:10010;">
        <div class="card" style="width:480px;">
          <h3>Edit Pool</h3>
          <div class="row">
            <input type="text" placeholder="Name" x-model="editPoolForm.name" style="flex:1;" />
            <select x-model.number="editPoolForm.account_id" style="flex:1;">
              <option :value="null">No Account</option>
              <template x-for="a in accounts" :key="a.id">
                <option :value="a.id" x-text="a.name + (a.provider ? ' ('+a.provider+')' : '')"></option>
              </template>
            </select>
          </div>
          <div class="row" style="justify-content:flex-end; margin-top:1rem;">
            <button class="btn ghost" @click="editPoolOpen=false">Cancel</button>
            <button class="btn" @click="saveEditPool()">Save</button>
          </div>
        </div>
      </div>

      <!-- Delete Pool Confirm Modal -->
      <div x-show="deletePoolOpen" x-cloak style="position:fixed; inset:0; background:rgba(0,0,0,.35); display:flex; align-items:center; justify-content:center; z-index:10010;">
        <div class="card" style="width:420px;">
          <h3>Confirm Delete</h3>
          <p>Are you sure you want to delete <strong x-text="deletePoolTarget?.name"></strong>?</p>
          <template x-if="deletePoolChildren.length">
            <div>
              <p class="muted">This pool has the following child pools that will also be deleted:</p>
              <ul>
                <template x-for="c in deletePoolChildren" :key="c.id">
                  <li x-text="c.name + ' ('+c.cidr+')'"></li>
                </template>
              </ul>
              <label><input type="checkbox" x-model="deletePoolCascade" /> Delete all children</label>
            </div>
          </template>
          <div class="row" style="justify-content:space-between; align-items:center; margin-top:1rem;">
            <label style="display:flex; align-items:center; gap:.4rem;"><input type="checkbox" x-model="confirmPoolDelete" /> I understand this action cannot be undone</label>
            <button class="btn ghost" @click="deletePoolOpen=false">Cancel</button>
            <button class="btn" :disabled="(!confirmPoolDelete) || (deletePoolChildren.length && !deletePoolCascade)" @click="performDeletePool()">Delete</button>
          </div>
        </div>
      </div>
    </section>
    </template>
    
    <template x-if="tab==='accounts'">
    <section x-data="accountsView()" x-init="fetchAccounts()" class="card">
      <h2>Accounts</h2>
      <div class="row">
        <input type="text" placeholder="Key (e.g., aws:123, gcp:proj)" x-model="acctForm.key" />
        <input type="text" placeholder="Name" x-model="acctForm.name" />
        <input type="text" placeholder="Provider (optional)" x-model="acctForm.provider" />
        <input type="text" placeholder="External ID (optional)" x-model="acctForm.external_id" />
        <input type="text" placeholder="Description (optional)" x-model="acctForm.description" />
        <input type="text" placeholder="Platform (optional)" x-model="acctForm.platform" />
        <select x-model="acctForm.tier">
          <option value="">Tier (optional)</option>
          <option value="dev">dev</option>
          <option value="stg">stg</option>
          <option value="sbx">sbx</option>
          <option value="prd">prd</option>
        </select>
        <input type="text" placeholder="Environment (optional)" x-model="acctForm.environment" />
        <input type="text" placeholder="Regions (comma-separated)" x-model="acctForm.regions_text" />
        <button class="btn" @click="createAccount()">Create</button>
        <span x-text="acctMsg" class="muted"></span>
      </div>
      <div class="row" style="justify-content:flex-end; margin:.4rem 0; position:relative;">
        <div style="margin-left:auto; position:relative;" x-data="{ open:false }">
          <button class="btn ghost" @click="open=!open">Columns ▾</button>
          <div x-show="open" x-cloak style="position:absolute; right:0; background:#fff; border:1px solid var(--border); border-radius:8px; box-shadow:var(--shadow); z-index:10020; padding:8px 10px; min-width:220px;">
            <div class="muted" style="margin-bottom:6px;">Toggle columns</div>
            <template x-for="col in Object.keys(visibleCols)" :key="col">
              <label style="display:flex; align-items:center; gap:.5rem;">
                <input type="checkbox" :checked="visibleCols[col]" @change="visibleCols[col]=!visibleCols[col]" />
                <span x-text="col.replace('_',' ').replace('_',' ')" style="text-transform: capitalize;"></span>
              </label>
            </template>
          </div>
        </div>
      </div>
      <div style="overflow-x:auto; width:100%;">
      <table style="min-width:960px; width:100%;">
        <thead>
          <tr>
            <th>ID</th>
            <th>Key</th>
            <th>Name</th>
            <th x-show="visibleCols.provider">Provider</th>
            <th x-show="visibleCols.external_id">External ID</th>
            <th x-show="visibleCols.description">Description</th>
            <th x-show="visibleCols.platform">Platform</th>
            <th x-show="visibleCols.tier">Tier</th>
            <th x-show="visibleCols.environment">Environment</th>
            <th x-show="visibleCols.regions">Regions</th>
            <th x-show="visibleCols.created">Created</th>
            <th></th>
          </tr>
        </thead>
        <tbody>
          <template x-for="a in accounts" :key="a.id">
            <tr x-data="{ open:false }" @click.outside="open=false">
              <td x-text="a.id"></td>
              <td x-text="a.key"></td>
              <td x-text="a.name"></td>
              <td x-show="visibleCols.provider" x-text="a.provider || '-' "></td>
              <td x-show="visibleCols.external_id" x-text="a.external_id || '-' "></td>
              <td x-show="visibleCols.description" x-text="a.description || '-' "></td>
              <td x-show="visibleCols.platform" x-text="a.platform || '-' "></td>
              <td x-show="visibleCols.tier" x-text="a.tier || '-' "></td>
              <td x-show="visibleCols.environment" x-text="a.environment || '-' "></td>
              <td x-show="visibleCols.regions" x-text="Array.isArray(a.regions) && a.regions.length ? a.regions.join(', ') : '-' "></td>
              <td x-show="visibleCols.created" x-text="new Date(a.created_at).toLocaleString()"></td>
              <td style="position:relative; text-align:right;">
                <button class="btn ghost" @click="open=!open">⋮</button>
                <div x-show="open" x-cloak style="position:absolute; right:0; background:#fff; border:1px solid var(--border); border-radius:8px; box-shadow: var(--shadow); z-index:9999; min-width:140px;">
                  <button class="btn ghost" style="display:block; width:100%; text-align:left;" @click="open=false; openEditAccount(a)">Edit</button>
                  <button class="btn ghost" style="display:block; width:100%; text-align:left;" @click="open=false; confirmDeleteAccount(a)">Delete</button>
                </div>
              </td>
            </tr>
          </template>
          <tr x-show="accounts.length === 0"><td :colspan="accountsColumnsCount()" style="color:#999">No accounts yet</td></tr>
        </tbody>
      </table>
      </div>
      <script>
        function accountsView() {
          return {
            accounts: [],
            acctForm: { key:'', name:'', provider:'', external_id:'', description:'', platform:'', tier:'', environment:'', regions_text:'' },
            acctMsg: '',
            editOpen: false,
            editForm: { id:null, name:'', provider:'', external_id:'', description:'', platform:'', tier:'', environment:'', regions_text:'', regions:[] },
            visibleCols: { provider:true, external_id:true, description:true, platform:true, tier:true, environment:true, regions:true, created:true },
            accountsColumnsCount(){
              // Always-visible: ID, Key, Name, Actions = 4
              let count = 4;
              for (const k in this.visibleCols) { if (this.visibleCols[k]) count++; }
              return count;
            },
            deleteOpen: false,
            deleteTarget: null,
            deleteChildren: [],
            deleteCascade: false,
            confirmAccountDelete: false,
            async fetchAccounts() {
              try {
                const res = await fetch('/api/v1/accounts');
                this.accounts = await res.json();
              } catch (e) { this.acctMsg = 'Failed to load accounts'; }
            },
            async createAccount() {
              this.acctMsg = '';
              try {
                // Basic validation: tier (if provided) must be one of dev/stg/sbx/prd
                const allowedTiers = ['dev','stg','sbx','prd'];
                if (this.acctForm.tier && !allowedTiers.includes(String(this.acctForm.tier).toLowerCase())) {
                  this.acctMsg = 'Tier must be one of dev, stg, sbx, prd'; showToast(this.acctMsg,'error'); return;
                }
                // Parse regions from comma-separated input
                const regions = (this.acctForm.regions_text||'').split(',').map(s=>s.trim()).filter(Boolean);
                // Validate simple region token format
                const bad = regions.find(r => !/^[a-z0-9-]+$/.test(r));
                if (bad) { this.acctMsg = `Invalid region token: ${bad}`; showToast(this.acctMsg,'error'); return; }
                const payload = {
                  key: this.acctForm.key,
                  name: this.acctForm.name,
                  provider: this.acctForm.provider,
                  external_id: this.acctForm.external_id,
                  description: this.acctForm.description,
                  platform: this.acctForm.platform,
                  tier: this.acctForm.tier || '',
                  environment: this.acctForm.environment,
                  regions: regions,
                };
                const res = await fetch('/api/v1/accounts', {
                  method: 'POST', headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify(payload)
                });
                if (!res.ok) { this.acctMsg = await parseError(res); showToast(this.acctMsg,'error'); return; }
                this.acctForm = { key:'', name:'', provider:'', external_id:'', description:'', platform:'', tier:'', environment:'', regions_text:'' };
                await this.fetchAccounts();
                this.acctMsg = 'Created'; showToast('Account created');
              } catch (e) { this.acctMsg = 'Create failed'; }
            }
            ,
            openEditAccount(a) {
              this.editForm = { id:a.id, name:a.name, provider:a.provider||'', external_id:a.external_id||'', description:a.description||'', platform:a.platform||'', tier:a.tier||'', environment:a.environment||'', regions:Array.isArray(a.regions)?a.regions.slice():[], regions_text:(Array.isArray(a.regions)&&a.regions.length?a.regions.join(', '):'') };
              this.editOpen = true;
            }
            ,
            async saveAccount() {
              const f = this.editForm;
              try {
                // Validate tier
                const allowedTiers = ['dev','stg','sbx','prd'];
                if (f.tier && !allowedTiers.includes(String(f.tier).toLowerCase())) { this.acctMsg = 'Tier must be one of dev, stg, sbx, prd'; showToast(this.acctMsg,'error'); return; }
                const regions = (f.regions_text||'').split(',').map(s=>s.trim()).filter(Boolean);
                const bad = regions.find(r => !/^[a-z0-9-]+$/.test(r));
                if (bad) { this.acctMsg = `Invalid region token: ${bad}`; showToast(this.acctMsg,'error'); return; }
                const payload = { name:f.name, provider:f.provider, external_id:f.external_id, description:f.description, platform:f.platform, tier:f.tier||'', environment:f.environment, regions: regions };
                const res = await fetch(`/api/v1/accounts/${f.id}`, { method:'PATCH', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
                if (!res.ok) { this.acctMsg = await parseError(res); showToast(this.acctMsg,'error'); return; }
                this.editOpen = false;
                await this.fetchAccounts();
                this.editOpen = false; // ensure modal closes after refresh
                showToast('Account updated');
              } catch (e) { this.acctMsg = 'Update failed'; }
            }
            ,
            confirmDeleteAccount(a) {
              this.deleteTarget = a; this.deleteCascade = false; this.deleteChildren = []; this.confirmAccountDelete = false;
              // Fetch pools and compute affected pools
              fetch('/api/v1/pools').then(r=>r.json()).then(list => {
                const byParent = new Map();
                for (const p of list) { if (p.parent_id) { const arr = byParent.get(p.parent_id) || []; arr.push(p); byParent.set(p.parent_id, arr); } }
                const roots = list.filter(p => p.account_id === a.id);
                const byId = new Map(list.map(p=>[p.id,p]));
                const out = [];
                const stack = roots.map(r=>r.id);
                while (stack.length) {
                  const id = stack.pop();
                  const p = byId.get(id); if (p) out.push(p);
                  const children = byParent.get(id) || [];
                  for (const c of children) { stack.push(c.id); }
                }
                this.deleteChildren = out;
              });
              this.deleteOpen = true;
            }
            ,
            async deleteAccount(a) {
              if (!a) a = this.deleteTarget;
              if (!a) return;
              try {
                const force = this.deleteCascade ? '?force=1' : '';
                const res = await fetch(`/api/v1/accounts/${a.id}${force}`, { method: 'DELETE' });
                if (!res.ok) { this.acctMsg = await parseError(res); showToast(this.acctMsg,'error'); return; }
                await this.fetchAccounts();
                this.deleteOpen = false;
                this.acctMsg = 'Deleted'; showToast('Account deleted');
              } catch (e) { this.acctMsg = 'Delete failed'; }
            }
          }
        }
      </script>
      <!-- Edit Account Modal -->
      <div x-show="editOpen" x-cloak style="position:fixed; inset:0; background:rgba(0,0,0,.35); display:flex; align-items:center; justify-content:center; z-index:10010;">
        <div class="card" style="width:520px;">
          <h3>Edit Account</h3>
          <div class="row">
            <input type="text" placeholder="Name" x-model="editForm.name" style="flex:1;" />
            <input type="text" placeholder="Provider" x-model="editForm.provider" style="flex:1;" />
          </div>
          <div class="row">
            <input type="text" placeholder="External ID" x-model="editForm.external_id" style="flex:1;" />
            <input type="text" placeholder="Description" x-model="editForm.description" style="flex:1;" />
          </div>
          <div class="row">
            <input type="text" placeholder="Platform" x-model="editForm.platform" style="flex:1;" />
            <select x-model="editForm.tier" style="flex:1;">
              <option value="">Tier (optional)</option>
              <option value="dev">dev</option>
              <option value="stg">stg</option>
              <option value="sbx">sbx</option>
              <option value="prd">prd</option>
            </select>
          </div>
          <div class="row">
            <input type="text" placeholder="Environment" x-model="editForm.environment" style="flex:1;" />
            <input type="text" placeholder="Regions (comma-separated)" x-model="editForm.regions_text" style="flex:1;" />
          </div>
          <div class="row" style="justify-content:flex-end; margin-top:1rem;">
            <button class="btn ghost" @click="editOpen=false">Cancel</button>
            <button class="btn" @click="saveAccount()">Save</button>
          </div>
        </div>
      </div>

      <!-- Delete Account Confirm Modal -->
      <div x-show="deleteOpen" x-cloak style="position:fixed; inset:0; background:rgba(0,0,0,.35); display:flex; align-items:center; justify-content:center; z-index:10010;">
        <div class="card" style="width:420px;">
          <h3>Confirm Delete</h3>
          <p>Are you sure you want to delete <strong x-text="deleteTarget?.name"></strong>?</p>
          <template x-if="deleteChildren.length">
            <div>
              <p class="muted">The following pools (and their descendants) are associated and will be deleted:</p>
              <ul>
                <template x-for="p in deleteChildren" :key="p.id">
                  <li x-text="p.name + ' ('+p.cidr+')'"></li>
                </template>
              </ul>
              <label><input type="checkbox" x-model="deleteCascade" /> Delete all associated pools</label>
            </div>
          </template>
          <div class="row" style="justify-content:space-between; align-items:center; margin-top:1rem;">
            <label style="display:flex; align-items:center; gap:.4rem;"><input type="checkbox" x-model="confirmAccountDelete" /> I understand this action cannot be undone</label>
            <button class="btn ghost" @click="deleteOpen=false">Cancel</button>
            <button class="btn" :disabled="(!confirmAccountDelete) || (deleteChildren.length && !deleteCascade)" @click="deleteAccount()">Delete</button>
          </div>
        </div>
      </div>
    </section>
    </template>

    <template x-if="tab==='analytics'">
    <section x-data="allBlocksView()" x-init="init()" class="card">
      <h2>All Assigned Blocks</h2>
      <div class="row" style="gap:1rem; align-items:stretch; margin-bottom:.5rem;">
        <div class="card" style="flex:1; min-width:280px;">
          <div style="font-weight:600; margin-bottom:.25rem;">Blocks by Parent Pool</div>
          <div id="chart-parent" x-ref="chartParent"></div>
        </div>
        <div class="card" style="flex:1; min-width:280px;">
          <div style="font-weight:600; margin-bottom:.25rem;">Address Space by Account</div>
          <div id="chart-account" x-ref="chartAccount"></div>
        </div>
      </div>
      <div class="card" style="margin-bottom:.5rem;">
        <div style="font-weight:600; margin-bottom:.25rem;">Creations Over Time</div>
        <div id="chart-time" x-ref="chartTime"></div>
      </div>
      <div class="row" style="align-items:center; gap:1rem; position:relative;">
        <button class="btn" @click="filtersOpen=!filtersOpen">Filters ▾</button>
        <button class="btn ghost" @click="load()">Refresh</button>
        <button class="btn ghost" @click="clearFilters()">Clear</button>
        <span class="muted" x-text="summary()"></span>
        <span class="muted" x-text="msg"></span>
        <div style="margin-left:auto; position:relative;">
          <button class="btn ghost" @click="bulkOpen=!bulkOpen" :disabled="!selected.length" :title="selected.length ? (selected.length + ' selected') : 'Select rows to enable actions'">⋮</button>
          <div x-show="bulkOpen" x-cloak style="position:absolute; right:0; background:#fff; border:1px solid var(--border); border-radius:8px; box-shadow:var(--shadow); z-index:9999; min-width:180px;">
            <button class="btn ghost" style="display:block; width:100%; text-align:left;" @click="bulkOpen=false; openBulkAssign()">Assign Account…</button>
            <button class="btn ghost" style="display:block; width:100%; text-align:left; color:var(--danger);" @click="bulkOpen=false; openBulkDelete()">Delete…</button>
          </div>
        </div>
        <div x-show="filtersOpen" x-cloak style="position:absolute; top:36px; left:0; background:#fff; border:1px solid var(--border); border-radius:10px; box-shadow:var(--shadow); padding:12px; display:flex; gap:16px; z-index:10020;">
          <div style="min-width:220px; max-height:260px; overflow:auto;">
            <div class="muted" style="margin-bottom:6px;">Accounts</div>
            <template x-for="a in accounts" :key="a.id">
              <label style="display:flex; align-items:center; gap:.5rem;">
                <input type="checkbox" :value="String(a.id)" @change="toggleInArray(selectedAccounts, String(a.id))" :checked="selectedAccounts.includes(String(a.id))" />
                <span x-text="a.name + (a.provider ? ' ('+a.provider+')' : '')"></span>
              </label>
            </template>
            <div class="muted" style="margin-top:.5rem;">Account name contains</div>
            <input type="text" placeholder="e.g., prod" x-model="fltAccountName" @input="load()" style="width:100%;" />
          </div>
          <div style="min-width:220px; max-height:260px; overflow:auto;">
            <div class="muted" style="margin-bottom:6px;">Parent Pools</div>
            <template x-for="p in parentPools" :key="p.id">
              <label style="display:flex; align-items:center; gap:.5rem;">
                <input type="checkbox" :value="String(p.id)" @change="toggleInArray(selectedPools, String(p.id))" :checked="selectedPools.includes(String(p.id))" />
                <span x-text="p.name + ' ('+p.cidr+')'"></span>
              </label>
            </template>
            <div class="muted" style="margin-top:.5rem;">CIDR contains</div>
            <input type="text" placeholder="e.g., 10.0.1." x-model="fltCIDR" @input="load()" style="width:100%;" />
          </div>
          <div style="min-width:220px; max-height:260px; overflow:auto;">
            <div class="muted" style="margin-bottom:6px;">Platform</div>
            <template x-for="pl in platforms()" :key="pl">
              <label style="display:flex; align-items:center; gap:.5rem;">
                <input type="checkbox" :value="pl" @change="toggleInArray(fltPlatforms, pl)" :checked="fltPlatforms.includes(pl)" />
                <span x-text="pl"></span>
              </label>
            </template>
            <div class="muted" style="margin:.5rem 0 6px;">Environment / Tier</div>
            <template x-for="env in environments()" :key="env">
              <label style="display:flex; align-items:center; gap:.5rem;">
                <input type="checkbox" :value="env" @change="toggleInArray(fltEnvs, env)" :checked="fltEnvs.includes(env)" />
                <span x-text="env"></span>
              </label>
            </template>
          </div>
          <div style="min-width:220px; max-height:260px; overflow:auto;">
            <div class="muted" style="margin-bottom:6px;">Regions</div>
            <template x-for="rg in regions()" :key="rg">
              <label style="display:flex; align-items:center; gap:.5rem;">
                <input type="checkbox" :value="rg" @change="toggleInArray(fltRegions, rg)" :checked="fltRegions.includes(rg)" />
                <span x-text="rg"></span>
              </label>
            </template>
          </div>
          <div style="display:flex; flex-direction:column; gap:.5rem; align-items:flex-end;">
            <button class="btn" @click="filtersOpen=false; page=1; load()">Apply</button>
            <button class="btn ghost" @click="clearFilters()">Clear</button>
          </div>
        </div>
      </div>
      <table>
        <thead>
          <tr><th style="width:32px;"><input type="checkbox" @change="toggleSelectAll($event)" :checked="allSelected()" :indeterminate="indeterminate()" /></th><th>ID</th><th>Name</th><th>CIDR</th><th>Parent Pool</th><th>Account</th><th>Network IP</th><th>Broadcast IP</th><th>Created</th></tr>
        </thead>
        <tbody>
          <template x-for="b in filtered()" :key="b.id">
            <tr>
              <td><input type="checkbox" :value="b.id" @change="toggleSelect(b.id)" :checked="selected.includes(b.id)" /></td>
              <td x-text="b.id"></td>
              <td x-text="b.name"></td>
              <td x-text="b.cidr"></td>
              <td x-text="b.parent_name"></td>
              <td x-text="b.account_name || '-' "></td>
              <td x-text="b.network_ip || '-' "></td>
              <td x-text="b.broadcast_ip || '-' "></td>
              <td x-text="new Date(b.created_at).toLocaleString()"></td>
            </tr>
          </template>
          <tr x-show="filtered().length === 0"><td colspan="9" style="color:#999">No assigned blocks match filters</td></tr>
        </tbody>
      </table>
      <!-- Bulk Assign (Analytics) -->
      <div x-show="bulkAssignOpen" x-cloak style="position:fixed; inset:0; background:rgba(0,0,0,.35); display:flex; align-items:center; justify-content:center; z-index:10010;">
        <div class="card" style="width:420px;">
          <h3>Assign Account to Selected</h3>
          <div class="row" style="align-items:center;">
            <select x-model.number="bulkAccountId" style="min-width: 14rem;">
              <option :value="null">No Account</option>
              <template x-for="a in accounts" :key="a.id">
                <option :value="a.id" x-text="a.name + (a.provider ? ' ('+a.provider+')' : '')"></option>
              </template>
            </select>
            <span class="muted" x-text="selected.length + ' item(s)'" />
          </div>
          <div class="row" style="justify-content:flex-end; margin-top:1rem;">
            <button class="btn ghost" @click="bulkAssignOpen=false">Cancel</button>
            <button class="btn" @click="performBulkAssign()">Apply</button>
          </div>
        </div>
      </div>
      <!-- Bulk Delete (Analytics) -->
      <div x-show="bulkDeleteOpen" x-cloak style="position:fixed; inset:0; background:rgba(0,0,0,.35); display:flex; align-items:center; justify-content:center; z-index:10010;">
        <div class="card" style="width:460px;">
          <h3>Delete Selected Blocks</h3>
          <label style="display:flex; gap:.4rem; align-items:center;"><input type="checkbox" x-model="bulkCascade" /> Cascade delete descendants</label>
          <label style="display:flex; gap:.4rem; align-items:center; margin-top:.5rem;"><input type="checkbox" x-model="confirmBulkDelete" /> I understand this cannot be undone</label>
          <div class="row" style="justify-content:flex-end; margin-top:1rem;">
            <button class="btn ghost" @click="bulkDeleteOpen=false">Cancel</button>
            <button class="btn" :disabled="!confirmBulkDelete" @click="performBulkDelete()">Delete</button>
          </div>
        </div>
      </div>
      <div class="row" style="justify-content:space-between; align-items:center; margin-top:.5rem;">
        <div class="muted" x-text="total ? `Showing ${fromItem}-${toItem} of ${total}` : ''"></div>
        <div class="row" style="align-items:center; gap:.5rem;">
          <button class="btn ghost" @click="firstPage()" :disabled="page<=1">« First</button>
          <button class="btn ghost" @click="prevPage()" :disabled="page<=1">‹ Prev</button>
          <div>Page <input type="number" min="1" x-model.number="pageInput" style="width:64px;" @keydown.enter.prevent="goToPage()" /> of <span x-text="totalPages"></span></div>
          <button class="btn ghost" @click="nextPage()" :disabled="page>=totalPages">Next ›</button>
          <button class="btn ghost" @click="lastPage()" :disabled="page>=totalPages">Last »</button>
        </div>
      </div>
      <script>
        function allBlocksView() {
          return {
            accounts: [],
            parentPools: [],
            selectedAccounts: [],
            selectedPools: [],
            filtersOpen: false,
            blocks: [],
            rawBlocks: [],
            msg: '',
            search: '',
            fltAccountName: '',
            fltCIDR: '',
            fltPlatforms: [],
            fltEnvs: [],
            fltRegions: [],
            pageSize: '50',
            page: 1,
            pageInput: 1,
            total: 0,
            totalPages: 1,
            fromItem: 0,
            toItem: 0,
            editOpen:false,
            editForm:{ id:null, name:'', account_id:null },
            deleteOpen:false,
            deleteTarget:null,
            deleteDescendants: [],
            deleteCascade: false,
            confirmBlockDelete: false,
            chartParent: null,
            chartAccount: null,
            chartTime: null,
            selected: [],
            bulkOpen: false,
            bulkAssignOpen: false,
            bulkDeleteOpen: false,
            bulkAccountId: null,
            bulkCascade: false,
            confirmBulkDelete: false,
            async init() {
              await Promise.all([this.fetchAccounts(), this.fetchParentPools()]);
              await this.load();
              this.renderCharts();
            },
            async fetchAccounts() {
              try { const res = await fetch('/api/v1/accounts'); this.accounts = await res.json(); }
              catch (e) { this.msg = 'Failed to load accounts'; }
            },
            async fetchParentPools() {
              try { const res = await fetch('/api/v1/pools'); const all = await res.json(); this.parentPools = all.filter(p => !p.parent_id); }
              catch (e) { this.msg = 'Failed to load pools'; }
            },
            async load() {
              this.msg = '';
              try {
                const q = new URLSearchParams();
                if (this.selectedAccounts.length) q.set('accounts', this.selectedAccounts.join(','));
                if (this.selectedPools.length) q.set('pools', this.selectedPools.join(','));
                if (this.pageSize !== 'all') { q.set('page_size', this.pageSize); q.set('page', this.page); }
                else { q.set('page_size', 'all'); }
                const res = await fetch('/api/v1/blocks?' + q.toString());
                if (!res.ok) { this.msg = await parseError(res); showToast(this.msg,'error'); return; }
              const data = await res.json();
              const items = Array.isArray(data) ? data : (data.items || []);
              this.rawBlocks = this.withDerivedIPs(items);
              const pageSizeNum = this.pageSize === 'all' ? items.length : parseInt(this.pageSize, 10);
              this.total = data.total ?? items.length;
              this.totalPages = this.pageSize === 'all' ? 1 : Math.max(1, Math.ceil(this.total / pageSizeNum));
              const startIdx = this.total === 0 ? 0 : ((this.page - 1) * (pageSizeNum || this.total)) + 1;
              const endIdx = this.total === 0 ? 0 : Math.min(this.total, (this.page - 1) * (pageSizeNum || this.total) + items.length);
              this.fromItem = startIdx;
              this.toItem = endIdx;
              this.pageInput = this.page;
              this.blocks = this.filtered();
              // prune selection
              const curIds = new Set(this.blocks.map(b=>b.id));
              this.selected = this.selected.filter(id=>curIds.has(id));
              this.renderCharts();
            } catch (e) { this.msg = 'Failed to load blocks'; }
            },
            clearFilters() { this.selectedAccounts = []; this.selectedPools = []; this.filtersOpen=false; this.page=1; this.load(); }
            ,
            filtered() {
              const src = this.rawBlocks;
              let arr = src;
              if (this.selectedAccounts.length) arr = arr.filter(b => this.selectedAccounts.includes(String(b.account_id)));
              if (this.selectedPools.length) arr = arr.filter(b => this.selectedPools.includes(String(b.parent_id)));
              if (this.fltAccountName) { const qn = this.fltAccountName.toLowerCase(); arr = arr.filter(b => (b.account_name||'').toLowerCase().includes(qn)); }
              if (this.fltCIDR) { const qc = this.fltCIDR.toLowerCase(); arr = arr.filter(b => (b.cidr||'').toLowerCase().includes(qc)); }
              if (this.fltPlatforms.length) arr = arr.filter(b => this.fltPlatforms.includes((b.account_platform||'').toLowerCase()));
              if (this.fltEnvs.length) {
                arr = arr.filter(b => {
                  const env = (b.account_environment||b.account_tier||'').toLowerCase();
                  return this.fltEnvs.includes(env);
                });
              }
              if (this.fltRegions.length) {
                arr = arr.filter(b => {
                  const regs = Array.isArray(b.account_regions) ? b.account_regions.map(r=>String(r).toLowerCase()) : [];
                  return this.fltRegions.some(r => regs.includes(r));
                });
              }
              const q = (this.search||'').toLowerCase();
              if (q) arr = arr.filter(b => String(b.id).includes(q) || (b.name||'').toLowerCase().includes(q) || (b.cidr||'').toLowerCase().includes(q) || (b.parent_name||'').toLowerCase().includes(q) || (b.account_name||'').toLowerCase().includes(q));
              return arr;
            }
            ,
            toggleSelect(id){ const i=this.selected.indexOf(id); if(i>=0) this.selected.splice(i,1); else this.selected.push(id); },
            toggleSelectAll(ev){ if (ev.target.checked){ this.selected = this.filtered().map(b=>b.id); } else { this.selected = []; } },
            allSelected(){ const data=this.filtered(); return data.length>0 && this.selected.length===data.length; },
            indeterminate(){ const data=this.filtered(); return this.selected.length>0 && this.selected.length<data.length; },
            openBulkAssign(){ this.bulkAssignOpen=true; this.bulkAccountId=null; },
            async performBulkAssign(){ const target=this.bulkAccountId ?? null; for (const id of this.selected){ try { await fetch(`/api/v1/pools?id=${id}`, { method:'PATCH', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ account_id: target }) }); } catch{} } this.bulkAssignOpen=false; await this.load(); showToast('Assigned account'); },
            openBulkDelete(){ this.bulkDeleteOpen=true; this.bulkCascade=false; this.confirmBulkDelete=false; },
            async performBulkDelete(){ for (const id of this.selected){ const force=this.bulkCascade?'&force=1':''; try { await fetch(`/api/v1/pools?id=${id}${force}`, { method:'DELETE' }); } catch{} } this.bulkDeleteOpen=false; this.selected=[]; await this.load(); showToast('Deleted selected'); },
            platforms(){ const set=new Set(); for (const a of this.accounts) { const v=(a.platform||'').toLowerCase(); if (v) set.add(v); } return Array.from(set).sort(); },
            environments(){ const set=new Set(); for (const a of this.accounts) { const v=((a.environment||a.tier)||'').toLowerCase(); if (v) set.add(v); } return Array.from(set).sort(); },
            regions(){ const set=new Set(); for (const a of this.accounts) { const arr=Array.isArray(a.regions)?a.regions:[]; for (const r of arr) { const v=String(r).toLowerCase(); if (v) set.add(v); } } return Array.from(set).sort(); },
            toggleInArray(arr, val){ const i=arr.indexOf(val); if(i>=0) arr.splice(i,1); else arr.push(val); },
            summary(){
              const parts=[];
              if (this.selectedAccounts.length) parts.push(`${this.selectedAccounts.length} account(s)`);
              if (this.selectedPools.length) parts.push(`${this.selectedPools.length} parent pool(s)`);
              return parts.length? 'Filters: '+parts.join(', ') : 'No filters applied';
            },
            withDerivedIPs(items) {
              const out = [];
              for (const it of (items||[])) {
                const cidr = it.cidr;
                const derived = deriveIPv4Range(cidr);
                out.push({ ...it, network_ip: derived?.network || null, broadcast_ip: derived?.broadcast || null });
              }
              return out;
            },
            // ---------- Charts ----------
            ensureCharts() {
              if (typeof ApexCharts === 'undefined') return;
              if (!this.chartParent && this.$refs.chartParent) {
                this.chartParent = new ApexCharts(this.$refs.chartParent, {
                  chart: { type: 'bar', height: 260, toolbar: { show: false } },
                  series: [{ name: 'Blocks', data: [] }],
                  xaxis: { categories: [] },
                  dataLabels: { enabled: false },
                  grid: { borderColor: '#eee' }
                });
                this.chartParent.render();
              }
              if (!this.chartAccount && this.$refs.chartAccount) {
                this.chartAccount = new ApexCharts(this.$refs.chartAccount, {
                  chart: { type: 'donut', height: 260, toolbar: { show: false } },
                  series: [], labels: [], legend: { position: 'bottom' }
                });
                this.chartAccount.render();
              }
              if (!this.chartTime && this.$refs.chartTime) {
                this.chartTime = new ApexCharts(this.$refs.chartTime, {
                  chart: { type: 'line', height: 260, toolbar: { show: false } },
                  series: [{ name: 'Created', data: [] }],
                  xaxis: { type: 'category', categories: [] },
                  stroke: { curve: 'smooth' }, dataLabels: { enabled: false }, grid: { borderColor: '#eee' }
                });
                this.chartTime.render();
              }
            },
            renderCharts() {
              this.ensureCharts();
              if (!this.chartParent || !this.chartAccount || !this.chartTime) return;
              const rows = this.filtered();
              // Bar: count by parent pool
              const byParent = new Map();
              for (const r of rows) { const k = r.parent_name || `#${r.parent_id}`; byParent.set(k, (byParent.get(k)||0)+1); }
              const parentCats = Array.from(byParent.keys());
              const parentVals = parentCats.map(k => byParent.get(k));
              this.chartParent.updateOptions({ xaxis: { categories: parentCats } });
              this.chartParent.updateSeries([{ name: 'Blocks', data: parentVals }]);
              // Donut: address space by account (usable hosts)
              const byAcct = new Map();
              for (const r of rows) {
                const lab = r.account_name || '-';
                const bits = this.cidrBits(r.cidr);
                const usable = this.usableHosts(bits);
                byAcct.set(lab, (byAcct.get(lab)||0) + usable);
              }
              const acctLabels = Array.from(byAcct.keys());
              const acctVals = acctLabels.map(k => byAcct.get(k));
              this.chartAccount.updateOptions({ labels: acctLabels });
              this.chartAccount.updateSeries(acctVals);
              // Line: creations per day
              const byDay = new Map();
              for (const r of rows) {
                const d = new Date(r.created_at);
                if (isNaN(d.getTime())) continue;
                const key = d.getFullYear()+ '-' + String(d.getMonth()+1).padStart(2,'0') + '-' + String(d.getDate()).padStart(2,'0');
                byDay.set(key, (byDay.get(key)||0)+1);
              }
              const dayCats = Array.from(byDay.keys()).sort();
              const dayVals = dayCats.map(k => byDay.get(k));
              this.chartTime.updateOptions({ xaxis: { categories: dayCats } });
              this.chartTime.updateSeries([{ name: 'Created', data: dayVals }]);
            },
            cidrBits(cidr){ if (!cidr) return null; const i=cidr.indexOf('/'); if(i<0) return null; const b=parseInt(cidr.slice(i+1),10); return isNaN(b)?null:b; },
            usableHosts(bits){ if (bits==null || bits<0 || bits>32) return 0; const total = Math.pow(2, 32-bits); if (bits <= 30) return Math.max(0, total - 2); return total; },
            async prevPage() { if (this.page > 1) { this.page--; await this.load(); } },
            async nextPage() { if (this.page < this.totalPages) { this.page++; await this.load(); } },
            async firstPage() { if (this.page !== 1) { this.page = 1; await this.load(); } },
            async lastPage() { if (this.page !== this.totalPages) { this.page = this.totalPages; await this.load(); } },
            async goToPage() {
              if (this.pageSize === 'all') return;
              let target = parseInt(this.pageInput, 10);
              if (!target || target < 1) target = 1;
              if (target > this.totalPages) target = this.totalPages;
              if (target === this.page) return;
              this.page = target;
              await this.load();
            },
            openEditBlock(b){ this.editForm = { id:b.id, name:b.name, account_id: null }; this.editOpen = true; }
            ,
            async saveEditBlock(){
              const f=this.editForm;
              try {
                const res = await fetch(`/api/v1/pools?id=${f.id}`, { method:'PATCH', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ name:f.name, account_id:f.account_id }) });
                if (!res.ok) { this.msg = await parseError(res); showToast(this.msg,'error'); return; }
                this.editOpen=false; await this.load(); showToast('Block updated');
              } catch(e){ this.msg='Update failed'; }
            }
            ,
            confirmDeleteBlock(b){
              this.deleteTarget=b; this.deleteCascade=false; this.deleteDescendants=[]; this.confirmBlockDelete=false;
              // fetch all pools to compute descendants of this sub-pool
              fetch('/api/v1/pools').then(r=>r.json()).then(list => {
                const byParent = new Map();
                for (const p of list) { if (p.parent_id) { const arr = byParent.get(p.parent_id) || []; arr.push(p); byParent.set(p.parent_id, arr); } }
                const out=[]; const stack=[b.id];
                while (stack.length){
                  const id=stack.pop();
                  const children = byParent.get(id) || [];
                  for (const c of children){ out.push(c); stack.push(c.id); }
                }
                this.deleteDescendants=out;
              });
              this.deleteOpen=true;
            }
            ,
            async deleteBlock(){ const b=this.deleteTarget; if(!b) return; try{ const force=this.deleteCascade?'&force=1':''; const res=await fetch(`/api/v1/pools?id=${b.id}${force}`, {method:'DELETE'}); if(!res.ok){ this.msg=await parseError(res); showToast(this.msg,'error'); return;} this.deleteOpen=false; await this.load(); showToast('Block deleted'); } catch(e){ this.msg='Delete failed'; } }
            ,
            downloadCsv() {
              const rows = this.filtered();
              const header = ['id','name','cidr','parent_id','parent_name','account_id','account_name','account_platform','account_environment','account_regions','network_ip','broadcast_ip','created_at'];
              const esc = v => '"' + String(v ?? '').replace(/"/g,'""') + '"';
              const fmtRegions = v => Array.isArray(v) ? v.join('|') : '';
              const lines = [header.join(',')].concat(rows.map(r => [r.id,r.name,r.cidr,r.parent_id,r.parent_name,r.account_id||'',r.account_name||'',r.account_platform||'',(r.account_environment||r.account_tier||''),fmtRegions(r.account_regions),r.network_ip||'',r.broadcast_ip||'',r.created_at].map(esc).join(',')));
              const blob = new Blob([lines.join('\n')], {type:'text/csv'});
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url; a.download = 'assigned_blocks.csv'; a.click();
              setTimeout(() => URL.revokeObjectURL(url), 2000);
            }
          }
        }
      </script>
      <!-- Edit Block Modal -->
      <div x-show="editOpen" x-cloak style="position:fixed; inset:0; background:rgba(0,0,0,.35); display:flex; align-items:center; justify-content:center; z-index:10010;">
        <div class="card" style="width:520px;">
          <h3>Edit Block</h3>
          <div class="row">
            <input type="text" placeholder="Name" x-model="editForm.name" style="flex:1;" />
            <select x-model.number="editForm.account_id" style="flex:1;">
              <option :value="null">No Account</option>
              <template x-for="a in accounts" :key="a.id">
                <option :value="a.id" x-text="a.name + (a.provider ? ' ('+a.provider+')' : '')"></option>
              </template>
            </select>
          </div>
          <div class="row" style="justify-content:flex-end; margin-top:1rem;">
            <button class="btn ghost" @click="editOpen=false">Cancel</button>
            <button class="btn" @click="saveEditBlock()">Save</button>
          </div>
        </div>
      </div>
      <!-- Delete Block Confirm Modal -->
      <div x-show="deleteOpen" x-cloak style="position:fixed; inset:0; background:rgba(0,0,0,.35); display:flex; align-items:center; justify-content:center; z-index:10010;">
        <div class="card" style="width:420px;">
          <h3>Confirm Delete</h3>
          <p>Are you sure you want to delete <strong x-text="deleteTarget?.name"></strong>?</p>
          <template x-if="deleteTarget">
            <div>
              <p class="muted" x-show="deleteDescendants.length">This block has the following child sub-pools that will also be deleted:</p>
              <ul>
                <template x-for="p in deleteDescendants" :key="p.id">
                  <li x-text="p.name + ' ('+p.cidr+')'"></li>
                </template>
              </ul>
              <label x-show="deleteDescendants.length"><input type="checkbox" x-model="deleteCascade" /> Delete all children</label>
            </div>
          </template>
          <div class="row" style="justify-content:space-between; align-items:center; margin-top:1rem;">
            <label style="display:flex; align-items:center; gap:.4rem;"><input type="checkbox" x-model="confirmBlockDelete" /> I understand this action cannot be undone</label>
            <button class="btn ghost" @click="deleteOpen=false">Cancel</button>
            <button class="btn" :disabled="(!confirmBlockDelete) || (deleteDescendants.length && !deleteCascade)" @click="deleteBlock()">Delete</button>
          </div>
        </div>
      </div>
    </section>
    </template>
    </main>

      <script>
      async function parseError(res) {
        try { const data = await res.json(); return data.error || data.detail || res.statusText || 'Request failed'; }
        catch (e) { try { return await res.text(); } catch { return res.statusText || 'Request failed'; } }
      }
      function tabState(){
        return {
          tab: 'pools',
          init(){
            const h = (location.hash||'').replace('#','');
            if (['pools','accounts','analytics'].includes(h)) this.tab = h;
            this.$watch('tab', t => { history.replaceState(null,'','#'+t); });
          }
        }
      }
      function toaster(){
        return {
          toasts: [],
          init(){
            window.showToast = (message, type='info') => {
              window.dispatchEvent(new CustomEvent('toast', { detail: { message, type } }));
            };
            window.addEventListener('toast', (e) => {
              const id = Math.random().toString(36).slice(2);
              const t = { id, message: e.detail.message, type: e.detail.type || 'info' };
              this.toasts.push(t);
              setTimeout(() => { this.toasts = this.toasts.filter(x => x.id !== id); }, 3000);
            });
          }
        }
      }
      // Compute IPv4 network and broadcast for a CIDR (e.g., 10.0.1.0/24)
      function deriveIPv4Range(cidr) {
        if (!cidr || typeof cidr !== 'string' || !cidr.includes('/')) return null;
        const [ipStr, prefixStr] = cidr.split('/');
        const oct = ipStr.split('.').map(n => parseInt(n, 10));
        const p = parseInt(prefixStr, 10);
        if (oct.length !== 4 || oct.some(n => isNaN(n) || n < 0 || n > 255)) return null;
        if (isNaN(p) || p < 0 || p > 32) return null;
        const toInt = (a,b,c,d) => ((a<<24)>>>0) + (b<<16) + (c<<8) + d;
        const toStr = (x) => [ (x>>>24)&255, (x>>>16)&255, (x>>>8)&255, x&255 ].join('.');
        const ip = toInt(oct[0],oct[1],oct[2],oct[3])>>>0;
        const mask = (p === 0) ? 0 : (~((1<<(32-p)) - 1))>>>0; // network mask
        const network = (ip & mask) >>> 0;
        const broadcast = (network | (~mask >>> 0)) >>> 0;
        return { network: toStr(network), broadcast: toStr(broadcast) };
      }
      function ipToInt(ipStr){
        const oct = (ipStr||'').split('.').map(n=>parseInt(n,10));
        if (oct.length!==4 || oct.some(n=>isNaN(n)||n<0||n>255)) return null;
        return ((oct[0]<<24)>>>0) + (oct[1]<<16) + (oct[2]<<8) + oct[3];
      }
      function prefixRange(cidr){
        if (!cidr || typeof cidr !== 'string' || !cidr.includes('/')) return null;
        const [ipStr, prefixStr] = cidr.split('/');
        const base = ipToInt(ipStr); const p = parseInt(prefixStr,10);
        if (base==null || isNaN(p) || p<0 || p>32) return null;
        const mask = (p===0) ? 0 : (~((1<<(32-p)) - 1))>>>0;
        const start = (base & mask)>>>0;
        const end = (start | (~mask>>>0))>>>0;
        return { start, end };
      }
      function pools() {
        return {
          list: [],
          topLevel: [],
          accounts: [],
          form: { name: '', cidr: '', account_id: null},
          msg: '',
          selectedTop: [],
          bulkOpen: false,
          current: null,
          currentAccountId: null,
          updateMsg: '',
          editPoolOpen: false,
          editPoolForm: { id: null, name: '', account_id: null },
          bulkAssignTopOpen: false,
          bulkDeleteTopOpen: false,
          bulkAccountId: null,
          bulkCascade: false,
          confirmBulkDelete: false,
          deletePoolOpen: false,
          deletePoolTarget: null,
          deletePoolChildren: [],
          deletePoolCascade: false,
          confirmPoolDelete: false,
          blockPrefix: 24,
          currentPrefixBits: null,
          blocks: [],
          rawBlocks: [],
          showOnlyUsed: false,
          hideUnavailable: false,
          blockFilters: { hosts:'', status:'', account:'', network:'', broadcast:'' },
          subMsg: '',
          vizSearch: '',
          vizAccounts: [],
          vizSegments: [],
          pageSize: '50',
          page: 1,
          pageInput: 1,
          total: 0,
          totalPages: 1,
          fromItem: 0,
          toItem: 0,
          async init() {
            await Promise.all([this.fetchAccounts(), this.fetchList()]);
          },
          async fetchAccounts() {
            try {
              const res = await fetch('/api/v1/accounts');
              this.accounts = await res.json();
            } catch (e) {
              // ignore
            }
          },
          async fetchList() {
            try {
              const res = await fetch('/api/v1/pools');
              this.list = await res.json();
              this.topLevel = this.list.filter(p => !p.parent_id);
              // prune selections no longer present
              const ids = new Set(this.topLevel.map(p=>p.id));
              this.selectedTop = this.selectedTop.filter(id=>ids.has(id));
            } catch (e) {
              this.msg = 'Failed to load pools';
            }
          },
          toggleSelectTop(id){ const i=this.selectedTop.indexOf(id); if(i>=0) this.selectedTop.splice(i,1); else this.selectedTop.push(id); },
          toggleSelectAllTop(ev){ if (ev.target.checked){ this.selectedTop = this.topLevel.map(p=>p.id); } else { this.selectedTop = []; } },
          allTopSelected(){ return this.topLevel.length>0 && this.selectedTop.length===this.topLevel.length; },
          indeterminateTop(){ return this.selectedTop.length>0 && this.selectedTop.length<this.topLevel.length; },
          openBulkAssignTop(){ this.bulkAssignTopOpen=true; this.bulkAccountId=null; },
          async performBulkAssignTop(){
            const target = this.bulkAccountId ?? null;
            for (const id of this.selectedTop){
              try { await fetch(`/api/v1/pools?id=${id}`, { method:'PATCH', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ account_id: target }) }); } catch {}
            }
            this.bulkAssignTopOpen=false; await this.fetchList(); if(this.current){ const cur = this.list.find(x=>x.id===this.current.id); if(cur) this.current=cur; }
            showToast('Assigned account to selected');
          },
          openBulkDeleteTop(){ this.bulkDeleteTopOpen=true; this.bulkCascade=false; this.confirmBulkDelete=false; },
          async performBulkDeleteTop(){
            for (const id of this.selectedTop){
              const force = this.bulkCascade ? '&force=1' : '';
              try { await fetch(`/api/v1/pools?id=${id}${force}`, { method:'DELETE' }); } catch {}
            }
            this.bulkDeleteTopOpen=false; this.selectedTop=[]; await this.fetchList(); if (this.current && !this.list.find(x=>x.id===this.current.id)) this.current=null;
            showToast('Deleted selected pools');
          },
          accountName(id) {
            if (!id) return '-';
            const a = this.accounts.find(a => a.id === id);
            return a ? a.name : `#${id}`;
          },
          selectPool(p) { this.current = p; this.currentAccountId = p.account_id || null; this.blocks = []; this.subMsg=''; this.page=1; this.pageInput=1; this.total=0; this.totalPages=1; this.updateMsg=''; this.currentPrefixBits = this.cidrBits(p.cidr); if (this.currentPrefixBits!=null && (this.blockPrefix <= this.currentPrefixBits)) { this.blockPrefix = Math.min(32, this.currentPrefixBits+1); } this.computeViz(); },
          openEditPool(p) { this.editPoolForm = { id: p.id, name: p.name, account_id: p.account_id||null }; this.editPoolOpen = true; },
          async saveEditPool() {
            const f = this.editPoolForm;
            try {
              const res = await fetch(`/api/v1/pools?id=${f.id}`, { method:'PATCH', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ name: f.name, account_id: f.account_id }) });
              if (!res.ok) { this.msg = await parseError(res); showToast(this.msg,'error'); return; }
              const updated = await res.json();
              const idx = this.list.findIndex(x => x.id === updated.id);
              if (idx >= 0) this.list[idx] = updated;
              if (this.current && this.current.id === updated.id) this.current = updated;
              this.editPoolOpen = false;
              showToast('Pool updated');
            } catch (e) { this.msg = 'Update failed'; }
          },
          confirmDeletePool(p) {
            this.deletePoolTarget = p; this.deletePoolCascade = false; this.confirmPoolDelete = false;
            // Build descendant list from this.list
            const byParent = new Map();
            for (const x of this.list) { if (x.parent_id) { const arr = byParent.get(x.parent_id) || []; arr.push(x); byParent.set(x.parent_id, arr); } }
            const out = [];
            const stack = [p.id];
            while (stack.length) {
              const id = stack.pop();
              const children = byParent.get(id) || [];
              for (const c of children) { out.push(c); stack.push(c.id); }
            }
            this.deletePoolChildren = out;
            this.deletePoolOpen = true;
          },
          async performDeletePool() {
            const p = this.deletePoolTarget; if (!p) return;
            try {
              const force = this.deletePoolCascade ? '&force=1' : '';
              const res = await fetch(`/api/v1/pools?id=${p.id}${force}`, { method:'DELETE' });
              if (!res.ok) { this.msg = await parseError(res); showToast(this.msg,'error'); return; }
              await this.fetchList(); if (this.current && this.current.id===p.id) this.current=null; this.deletePoolOpen=false;
              showToast('Pool deleted');
            } catch (e) { this.msg='Delete failed'; }
          },
          onPageSize() { this.page = 1; this.loadBlocks(); },
          async loadBlocks() {
            if (!this.current) return;
            this.subMsg = '';
            try {
              const q = new URLSearchParams();
              q.set('new_prefix_len', this.blockPrefix);
              if (this.pageSize !== 'all') { q.set('page_size', this.pageSize); q.set('page', this.page); }
              else { q.set('page_size', 'all'); }
              const res = await fetch(`/api/v1/pools/${this.current.id}/blocks?${q.toString()}`);
              if (!res.ok) { this.subMsg = await parseError(res); showToast(this.subMsg,'error'); return; }
              const data = await res.json();
              if (Array.isArray(data)) {
                // Back-compat (shouldn't happen with new server)
                this.rawBlocks = this.withDerivedIPs(data);
                this.filterBlocks();
                this.total = data.length;
                this.totalPages = 1;
                this.fromItem = data.length ? 1 : 0;
                this.toItem = data.length;
              } else {
                this.rawBlocks = this.withDerivedIPs(data.items || []);
                this.total = data.total || 0;
                const pageSizeNum = this.pageSize === 'all' ? this.total : parseInt(this.pageSize, 10);
                this.totalPages = pageSizeNum > 0 ? Math.max(1, Math.ceil(this.total / pageSizeNum)) : 1;
                const startIdx = this.total === 0 ? 0 : ((this.page - 1) * (pageSizeNum || this.total)) + 1;
                const endIdx = this.total === 0 ? 0 : Math.min(this.total, (this.page - 1) * (pageSizeNum || this.total) + this.rawBlocks.length);
                this.fromItem = startIdx;
                this.toItem = endIdx;
                this.pageInput = this.page;
                this.filterBlocks();
              }
            } catch (e) { this.subMsg = 'Failed to load blocks'; }
          },
          filterBlocks() {
            const f = this.blockFilters;
            const normalize = (v) => (v ?? '').toString().toLowerCase();
            const hostsMatch = (b) => !f.hosts || normalize(b.hosts).includes(normalize(f.hosts));
            const statusStr = (b) => b.used ? 'used' : (this.blockUnavailable(b.cidr) ? 'unavailable' : 'free');
            const statusMatch = (b) => !f.status || statusStr(b).includes(normalize(f.status));
            const acct = (b) => (b.assigned_account_name || this.accountName(b.assigned_account_id) || '-');
            const accountMatch = (b) => !f.account || normalize(acct(b)).includes(normalize(f.account));
            const networkMatch = (b) => !f.network || normalize(b.network_ip || '').includes(normalize(f.network));
            const broadcastMatch = (b) => !f.broadcast || normalize(b.broadcast_ip || '').includes(normalize(f.broadcast));
            let arr = this.rawBlocks;
            if (this.showOnlyUsed) arr = arr.filter(b => b.used);
            if (this.hideUnavailable) arr = arr.filter(b => !(b.used || this.blockUnavailable(b.cidr)));
            this.blocks = arr.filter(b => hostsMatch(b) && statusMatch(b) && accountMatch(b) && networkMatch(b) && broadcastMatch(b));
          },
          blockUnavailable(cidr) {
            if (!this.current || !cidr) return false;
            // A block is unavailable if it overlaps any existing direct child of current
            const children = this.list.filter(p => p.parent_id === this.current.id);
            const br = prefixRange(cidr); if (!br) return false;
            for (const c of children) {
              if (c.cidr === cidr) return true; // exact match occupied
              const cr = prefixRange(c.cidr); if (!cr) continue;
              // intervals overlap if not disjoint
              if (!(br.end < cr.start || cr.end < br.start)) return true;
            }
            return false;
          },
          blockUnavailableReason(cidr) {
            if (!this.current || !cidr) return '';
            const children = this.list.filter(p => p.parent_id === this.current.id);
            const br = prefixRange(cidr); if (!br) return '';
            for (const c of children) {
              const cr = prefixRange(c.cidr); if (!cr) continue;
              if (c.cidr === cidr || !(br.end < cr.start || cr.end < br.start)) {
                const nm = c.name ? `\"${c.name}\"` : `#${c.id}`;
                return `Overlaps existing child ${nm} (${c.cidr})`;
              }
            }
            return '';
          },
          withDerivedIPs(items) {
            const out = [];
            for (const it of (items||[])) {
              const cidr = it.cidr;
              const derived = deriveIPv4Range(cidr);
              out.push({ ...it, network_ip: derived?.network || null, broadcast_ip: derived?.broadcast || null });
            }
            return out;
          },
          async prevPage() { if (this.page > 1) { this.page--; await this.loadBlocks(); } },
          async nextPage() { if (this.page < this.totalPages) { this.page++; await this.loadBlocks(); } },
          async firstPage() { if (this.page !== 1) { this.page = 1; await this.loadBlocks(); } },
          async lastPage() { if (this.page !== this.totalPages) { this.page = this.totalPages; await this.loadBlocks(); } },
          async goToPage() {
            if (this.pageSize === 'all') return;
            let target = parseInt(this.pageInput, 10);
            if (!target || target < 1) target = 1;
            if (target > this.totalPages) target = this.totalPages;
            if (target === this.page) return;
            this.page = target;
            await this.loadBlocks();
          },
          async createTop() {
            this.msg = '';
            try {
              const res = await fetch('/api/v1/pools', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(this.form)
              });
              if (!res.ok) { this.msg = await parseError(res); showToast(this.msg, 'error'); return; }
              this.form = { name: '', cidr: '' };
              await Promise.all([this.fetchList(), this.fetchAccounts()]);
              this.msg = 'Created';
              showToast('Pool created');
            } catch (e) {
              this.msg = 'Network error';
              showToast(this.msg, 'error');
            }
          },
          async updateCurrentPoolAccount() {
            if (!this.current) return;
            this.updateMsg = '';
            try {
              const res = await fetch(`/api/v1/pools/${this.current.id}`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ account_id: this.currentAccountId ?? null })
              });
              if (!res.ok) { this.updateMsg = await parseError(res); showToast(this.updateMsg,'error'); return; }
              const p = await res.json();
              // Update current and list
              this.current = p;
              const idx = this.list.findIndex(x => x.id === p.id);
              if (idx >= 0) this.list[idx] = p;
              await this.loadBlocks();
              this.updateMsg = 'Updated';
              this.computeViz();
            } catch (e) { this.updateMsg = 'Update failed'; }
          },
          cidrBits(cidr){ if (!cidr) return null; const i = cidr.indexOf('/'); if (i<0) return null; const b = parseInt(cidr.slice(i+1),10); return isNaN(b)?null:b; },
          computeViz() {
            if (!this.current) { this.vizSegments = []; return; }
            const curRange = prefixRange(this.current.cidr);
            if (!curRange) { this.vizSegments = []; return; }
            const base = curRange.start, total = (curRange.end - curRange.start + 1)>>>0;
            const q = (this.vizSearch||'').toLowerCase();
            const selected = this.vizAccounts || [];
            const segs = [];
            for (const p of this.list) {
              if (!p || p.id === this.current.id) continue;
              const pr = prefixRange(p.cidr);
              if (!pr) continue;
              if (!(pr.start >= base && pr.end <= curRange.end)) continue;
              if (selected.length) {
                const aid = p.account_id != null ? String(p.account_id) : '';
                if (!selected.includes(aid)) continue;
              }
              if (q) {
                const hay = ((p.name||'')+' '+(p.cidr||'')).toLowerCase();
                if (!hay.includes(q)) continue;
              }
              const left = ((pr.start - base) / total) * 100;
              const width = (Math.max(1, (pr.end - pr.start + 1)) / total) * 100;
              segs.push({ id:p.id, left, width, title:`${p.name||'-'} (${p.cidr})`, color:'#93c5fd' });
            }
            this.vizSegments = segs;
          },
          async createSub(b) {
            if (!this.current) return;
            const name = prompt(`Name for sub-pool ${b.cidr}`);
            if (!name) return;
            const accountId = this.form.account_id || null;
            try {
              const res = await fetch('/api/v1/pools', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ name, cidr: b.cidr, parent_id: this.current.id, account_id: accountId })
              });
              if (!res.ok) { this.subMsg = await parseError(res); showToast(this.subMsg,'error'); return; }
              await this.fetchList();
              await this.loadBlocks(); this.computeViz(); showToast('Sub-pool created');
              this.subMsg = 'Sub-pool created';
            } catch (e) {
              this.subMsg = 'Network error creating sub-pool';
            }
          },
          selectPoolById(id) {
            const p = this.list.find(p => p.id === id);
            if (p) this.selectPool(p);
          }
        }
      }
    </script>
  </body>
</html>
